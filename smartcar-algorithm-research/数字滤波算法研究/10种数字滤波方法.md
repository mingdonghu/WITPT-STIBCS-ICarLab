

# 前言

## 0.应用场景

- 嵌入式系统设备进行数据采集时，会遇到数据的随机误差。
- 随机误差是由随机干扰引起的，其特点是在相同条件下测量同一量时，其大小和符号会现无规则的变化而无法预测，但多次测量的结果符合统计规律。
- 为克服随机干扰引起的误差，硬件上可采用滤波技术（R\L\C组合成的滤波电路），软件上可采用软件算法实现数字滤波。

- 软件算法滤波的优势：
  - 1）数字滤波无需其他的硬件成本，只用一个计算过程，可靠性高，不存在阻抗匹配问题。尤其是数字滤波可以对频率很低的信号进行滤波，这是模拟滤波器做不到的。
  - 2）数字滤波使用软件算法实现，多输入通道可共用一个滤波程序，降低系统开支。
  - 3）只要适当改变滤波器的滤波程序或运算，就能方便地改变其滤波特性，这对于滤除低频干扰和随机信号会有较大的效果。

## 1.限幅滤波法

-  A、方法：
  -  根据经验判断，确定两次采样允许的最大偏差值（设为A）
  - 每次检测到新值时判断：
  - 如果本次值与上次值之差<=A,则本次值有效
  - 如果本次值与上次值之差>A,则本次值无效,放弃本次值,用上次值代替本次值

-  B、优点：
  - 能有效克服因偶然因素引起的脉冲干扰
-  C、缺点
  - 无法抑制那种周期性的干扰
  - 平滑度差
- D、注意
  - 限幅滤波主要用于处理变化较为缓慢的数据，如温度、物体的位置等。使用时，关键要选取合适的门限值A，通常可由经验数据获得，必要时也可通过实验得到。

 ```c
 #define A  200//允许的最大差值
 
 #define CLAC_ABS(x)  ((x) >= 0 ? (x) : -(x))
  
 size_t LimitingFilter(size_t (*get_data)(void))
 {
     static size_t last_data = 0; //记录上一次获取的数据
     size_t new_data = 0; 
     size_t out_data = 0;
  
     new_data = get_data(); //获得新数据变量
  
     if(CLAC_ABS(new_data - last_data) > A)
     {
         out_data = last_data;
         last_data = out_data;
     }
     else
     {
         out_data = new_data;
         last_data = new_data;
     }
     return out_data;
 }
       
 ```



## 2.中位值滤波法

- A、方法：
  - 连续采样N次（N取奇数）
  - 把N次采样值按大小排列
  - 取中间值为本次有效值

- B、优点：
  - 能有效克服因偶然因素引起的波动干扰
  - 对温度、液位的变化缓慢的被测参数有良好的滤波效果

- C、缺点：
  - 对流量、速度等快速变化的参数不宜

- D、注意：
  - 中值滤波比较适用于去掉由偶然因素引起的波动和采样器不稳定而引起的脉动干扰。若被测量值变化比较慢，采用中值滤波法效果会比较好，但如果数据变化比较快，则不宜采用此方法。

 ```c
 #define N 11 //定义获得的数据个数(奇数个)
  
 size_t MidValFilter(size_t (*get_data)(void))
 {
     size_t value_buff[N]; //定义存储数据的数组
     size_t count,i,j,temp;
  
     for(count = 0; count < N; count++)
     {
         value_buf[count] = get_data();
         delay(); //如果数据采集比较慢，那么就需要延时或中断
     }
  
     //冒泡排序
     for(i = 0; i < N - 1; i++)
     {
         for(j = 0; j < N - 1 - i; j++ )
         {
             if(value_buff[i] > value_buffer[i + 1])
             {
                 temp = value_buff[i];
                 value_buff[i] = value_buff[i + 1];
                 value_buff[i + 1] = temp;
             }
         }
     }
     return value_buff[(N-1)/2];
 }
 ```



## 3.算术平均滤波法

- A、方法：
  - 连续取N个采样值进行算术平均运算
  - N值较大时：信号平滑度较高，但灵敏度较低
  - N值较小时：信号平滑度较低，但灵敏度较高
  - N值的选取：一般流量，N=16；压力：N=4

- B、优点：
  - 适用于对一般具有随机干扰的信号进行滤波
  - 这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动

- C、缺点：
  - 对于测量速度较慢或要求数据计算速度较快的实时控制不适用
  - 比较浪费RAM

- D、注意：
  - 算术平均滤波算法适用于对具有随机干扰的信号进行滤波。这种信号的特点是信号在某一数值附近上下波动。信号的平均平滑程度完全到决于N值。为了方便求平均值，N一般取4、8、16、32之类的2的整数幂，以便在程序中用右移位操作来代替除法。

```c
#define AVE_N 16
 
size_t AveFilter(size_t (*get_data)(void))
{
    size_t sum = 0;
 
    for(size_t count = 0; count < AVE_N; count++)
    {
        sum += get_data();
        delay():
    }
    return (size_t)(sum / AVE_N);
}
```



## 4.滑动平均滤波法

- A、方法：
  - 把连续取N个采样值看成一个队列
  - 队列的长度固定为N
  - 每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)
  - 把队列中的N个数据进行算术平均运算,就可获得新的滤波结果
  - N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4

- B、优点：
  - 对周期性干扰有良好的抑制作用，平滑度高
  - 适用于高频振荡的系统  

- C、缺点：
  - 灵敏度低
  - 对偶然出现的脉冲性干扰的抑制作用较差
  - 不易消除由于脉冲干扰所引起的采样值偏差
  - 不适用于脉冲干扰比较严重的场合
  - 比较浪费RAM

 ```c
 #define N 10
  
 size_t SlideAveFilter(size_t (*get_data)(void))
 {
     size_t sum = 0;
     static  size_t i = 0;
     static size_t value_buff[N] = {0};
  
     value_buff[i++] = get_data();
  
     if(i == N) {
       sum += value_buff[i-1];
       i = 0;
     } else {
       sum += value_buff[i];
     }
     
     return (size_t)(sum / N);
 }
 ```

 

## 5.中位值平均滤波法

- A、方法：
  - 相当于“中位值滤波法”+“算术平均滤波法”（又称防脉冲干扰平均滤波法）
  - 连续采样N个数据，去掉一个最大值和一个最小值，然后计算N-2个数据的算术平均值
  - N值的选取：3~14

- B、优点：
  - 融合了两种滤波法的优点
  - 对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差

- C、缺点：
  - 测量速度较慢，和算术平均滤波法一样
  - 比较浪费RAM



## 6.限幅平均滤波法

- A、方法：
  - 相当于“限幅滤波法”+“递推平均滤波法”
  - 每次采样到的新数据先进行限幅处理，再送入队列进行递推平均滤波处理

- B、优点：
  - 融合了两种滤波法的优点
  - 对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差

- C、缺点：
  - 比较浪费RAM

 

## 7.一阶滞后滤波法

- A、方法：
  - 取a=0~1
  - 本次滤波结果=（1-a）*本次采样值+a*上次滤波结果

- B、优点：
  - 对周期性干扰具有良好的抑制作用
  - 适用于波动频率较高的场合

- C、缺点：
  - 相位滞后，灵敏度低
  - 滞后程度取决于a值大小
  - 不能消除滤波频率高于采样频率的1/2的干扰信号

 ```c
 /* 为加快程序处理速度假定基数为100，a=0~100 */
 #define a 50
 
 char value;
 
 char filter()
 {
   char new_value;
   new_value = get_ad();
   return (100-a)*value + a*new_value; 
 }
 ```



## 8.加权平均滤波法

- A、方法：
  - 是对平均滤波法的改进，即不同时刻的数据加以不同的权
  - 通常是，越接近现时刻的数据，权取得越大。
  - 给予新采样值的权系数越大，则灵敏度越高，但信号平滑度越低

- B、优点：
  - 适用于有较大纯滞后时间常数的对象和采样周期较短的系统

- C、缺点：
  - 对于纯滞后时间常数较小，采样周期较长，变化缓慢的信号
  - 不能迅速反应系统当前所受干扰的严重程度，滤波效果差

```c
//如果在C51上实现这个算法，建议把加权系数数组的存储类型改为code,使数据存放与程序存储区，如下所示
/*
    size_t code Jq[12]={1,2,3,4,5,6,7,8,9,10,11,12}; //code数组为加权系数表，存在程序存储区
    size_t code JqSum=1+2+3+4+5+6+7+8+9+10+11+12;
*/
//下面写一个通式做法！
 
size_t Jq[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
 
size_t JqAveFilter(size_t (*get_data)(void), size_t *jq_coef, size_t coef_num)
{
    size_t sum = 0;
    size_t jq_coefficient_sum = 0;
 
    if(!num)
    {
        return 0;
    }
 
    for(size_t count = 0; count < coef_num; count++)
    {
        sum += (jq_coef[count] * get_data());
        jq_coefficient_sum += jq_coef[count];
        delay();
    }
 
    return (size_t)(sum / jq_coefficient_sum);
}
```



## 9.消抖滤波法

- A、方法：
  - 设置一个滤波计数器将每次采样值与当前有效值比较：
  - 如果采样值＝当前有效值，则计数器清零
  - 如果采样值<>当前有效值，则计数器+1，并判断计数器是否>=上限N(溢出)
  - 如果计数器溢出,则将本次值替换当前有效值,并清计数器

- B、优点：
  - 对于变化缓慢的被测参数有较好的滤波效果,可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动

- C、缺点：
  - 对于快速变化的参数不宜，如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值导入系统

 ```c
 #define N 12
 
 char filter()
 {
   char count=0;
   char new_value;
   static char old_value = 0;
   new_value = get_ad();
   while (old_value != new_value)
   {
      count++;
      if (count>=N)
      {
         old_value = new_value;
         return new_value;
      }
 	 delay();
      new_value = get_ad();
   }
   return old_value;  
 }
 ```



 ## 10.限幅消抖滤波法

- A、方法：
  - 相当于“限幅滤波法”+“消抖滤波法”，即：先限幅,后消抖

- B、优点：
  - 继承了“限幅”和“消抖”的优点
  - 改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统

- C、缺点：
  - 对于快速变化的参数不宜

 